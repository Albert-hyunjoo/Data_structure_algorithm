# 컬렉션 자료구조
* 컬렉션 자료구조는 데이터 미연관시키며 단순히 컨테이너의 역할
* 모든 컬렉션 자료구조는 in (멤버십), 크기 (len), 반복성 (iter)를 지원한다.

## 셋 (set)
* 셋은 집합으로, 일반적인 집합의 특징을 지닌 데이터 타입이다.
    * 반복이 가능하고 (iterate)
    * 가변적이므로 언제든 데이터 추가가 되며
    * 중복 요소가 존재하지 않고
    * 정렬되지 않은 데이터 타입
* 연관되지 않았으므로 데이터 삽입은 상수 O(1)을 유지하되, 인덱스는 불가하다.
* 주로 중복 항목 제거와 멤버십 데스트에 사용된다.
* 합집합은 O(m+n)이고 교집합은 m, n 중 작은 쪽에 O(n)

### 셋의 메서드에 대해서
* `A.add(x)` : 세트 A에 x가 없는 경우에 추가한다.
* `A.update(B)`: 세트 A와 B의 합집합을 출력한다.
    * `A.union(B)`은 같은 합집합이지만 *복사본을 출력한다*.
* `A.interaction(B)`: 세트 A와 B의 교집합의 *복사본* 을 출력한다.
* `A.difference(B)`: 세트 A와 B의 차집합의 *복사본* 을 반환한다.
* `A.clear()`: A의 모든 항목을 지운다.

### 셋과 리스트

* **리스트 타입**은 셋 타입으로 변환이 가능하다 (셋의 특징 모두 적용)
* **딕셔너리 타입**도 셋 속성의 사용이 가능하다 (셋의 교/합/차집합 메서드 OK)

## 딕셔너리 (Dictionary)
* 파이썬 딕셔너리는 해시 테이블로, 각각 key, value의 한 쌍으로 구성된다.
* 특정 객체 탐색에 key만 있으면 순회를 하지 않아도 되므로 상수 시간 내에 계산한다.
* 주로 연관 배열의 인덱스로 자주 사용된다. 
* 단, 딕셔너리는 **항목의 삽입 순서를 기억하지 않**으므로 **인덱스 및 슬라이스 사용이 불가**하다.

### 딕셔너리의 메서드
* `setdefault(key, default)`: 만약 A가 key가 있으면 키에 해당하는 value, 아니면 default가 저장
* `A.update(B)`: A에 B의 key:value쌍이 존재하면 update, 없으면 추가
* `A.get(key)`: 딕셔너리 A의 key 값을 반환하고, 없으면 무응답
* `A.items(), values(), keys()`: 각자의 값들을 프린트한다 (객체별)

#### 딕셔너리 분기 활용법

통상적으로는 if문을 활용하여 분기문을 작성하는 경우가 많지만,  
```python
action = "h"
if action == h:  
hello()  
elif action == "w":  
world()
```
딕셔너리를 활용해서 사용하면 분기를 효율적으로 할 수 있다.  
```python
functions = dict(h=hello, w=world)
functions[action]()
```

## 다양한 컬렉션 데이터 타입

### 기본 딕셔너리
* `collections.defaultdict`로 사용이 가능하다.
* 이는 내장 딕셔너리의 모든 연산자, 메서드 + 누락 키도 처리 가능하다.

### 정렬된 딕셔너리
* `collections.OrderedDict` 로 사용이 가능하다.
* 이는 내장 딕셔너리의 모든 메서드 및 속성 + 삽입 순서를 기억한다.
* 즉, 키 값을 변경한다 하더라고 삽입 순서는 바뀌지 않는다.
* 딕셔너리를 **여러 번 순회**해야 하거나 **항목 삽입이 없을 경우** 주로 사용한다.

### 카운터 딕셔너리

* 카운터 타입은 해시 가능한 객체를 카운팅하는 특화된 서브 클래스이다.
* `collections.Counter`로 활성화한다.

#### 카운터 딕셔너리의 예시

```python
from collections import Counter

# Counter는 딕셔너리 형태로 카운트를 저장해놓는다.
def counter_example():
    seq1 = [1,2,3,5,1,2,5,5,2,5,1,4]
    seq_counts = Counter(seq1)
    print(seq_counts)
```
